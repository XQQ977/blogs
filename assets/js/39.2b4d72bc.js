(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{460:function(t,_,v){"use strict";v.r(_);var a=v(2),e=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"一、javascript"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、javascript"}},[t._v("#")]),t._v(" 一、JavaScript")]),t._v(" "),_("h2",{attrs:{id:"_1-数据类型-8种"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据类型-8种"}},[t._v("#")]),t._v(" 1.数据类型（8种）")]),t._v(" "),_("table",[_("tr",[_("th",[t._v("基本数据类型")]),t._v(" "),_("th",[t._v("引用数据类型")])]),t._v(" "),_("tr",[_("td",[t._v("Undefined、Null、Boolean、String、Number、Symbol(ES6)、BigInt(ES6)")]),t._v(" "),_("td",[t._v("Object(包括数组、函数、对象等)")])])]),t._v(" "),_("ul",[_("li",[t._v("Symbol代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题")]),t._v(" "),_("li",[t._v("BigInt是一种数据类型的数据，它可以表示任意精度格式的整数，使用BigInt可以安全地存储和操作大整数，即使这个数已经超出了Number能够表示的安全整数范围")])]),t._v(" "),_("h2",{attrs:{id:"_2-堆内存与栈内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-堆内存与栈内存"}},[t._v("#")]),t._v(" 2.堆内存与栈内存")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("在操作系统中，内存被分为栈区和堆区")]),t._v("，栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。")])]),t._v(" "),_("p",[t._v("在数据结构中，栈中数据的存取方式为先进后出。堆是一个优先队列，是按照优先级进行排序的，优先级可以按照大小来规定")]),t._v(" "),_("p",[t._v("数据存储方式")]),t._v(" "),_("ul",[_("li",[t._v("基本数据类型的数据直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储")]),t._v(" "),_("li",[t._v("引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。")])]),t._v(" "),_("img",{attrs:{src:t.$withBase("/images/1.png"),alt:"mixureSecure"}}),t._v(" "),_("h2",{attrs:{id:"_3-数据类型检测"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-数据类型检测"}},[t._v("#")]),t._v(" 3.数据类型检测")]),t._v(" "),_("table",[_("tr",[_("th",[t._v("优缺点")]),t._v(" "),_("th",[t._v("typeof")]),t._v(" "),_("th",[t._v("instanceof")]),t._v(" "),_("th",[t._v("constructor")]),t._v(" "),_("th",[t._v("Object.prototype.toString.call")])]),t._v(" "),_("tr",[_("td",[t._v("优点")]),t._v(" "),_("td",[t._v("使用简单")]),t._v(" "),_("td",[t._v("能检测出引用类型数据")]),t._v(" "),_("td",[t._v("基本能检测出所有的类型（除了Null和Undefined）")]),t._v(" "),_("td",[t._v("检测出所有的类型")])]),t._v(" "),_("tr",[_("td",[t._v("缺点")]),t._v(" "),_("td",[t._v("只能检测出除null外的基本数据类型和引用数据类型中的function")]),t._v(" "),_("td",[t._v("不能检测出基本类型，且不能跨iframe")]),t._v(" "),_("td",[t._v("constructor易被修改，也不能跨iframe")]),t._v(" "),_("td",[t._v("IE6下，undefined和null均为Object")])])]),t._v(" "),_("h2",{attrs:{id:"_4-判断数组的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-判断数组的方式"}},[t._v("#")]),t._v(" 4.判断数组的方式")]),t._v(" "),_("ul",[_("li",[t._v("Object.prototype.toString.call([1,2,3]) // [object Array]")]),t._v(" "),_("li",[t._v("通过ES6的Array.isArray([1,2,3])做判断 // true or false")]),t._v(" "),_("li",[t._v("[1,2,3] instanceof Array // true or false")]),t._v(" "),_("li",[t._v("Array.prototype.isPrototypeOf([1,2,3]) // true or false")]),t._v(" "),_("li",[t._v("通过原型链去判断：[1,2,3]."),_("em",[t._v("proto")]),t._v(" === Array.prototype")])]),t._v(" "),_("h2",{attrs:{id:"_5-undefined与null"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-undefined与null"}},[t._v("#")]),t._v(" 5.Undefined与Null")]),t._v(" "),_("ul",[_("li",[t._v("Undefined和Null都是基本数据类型，这两个基本数据类型分别都只有一个值，就是undefined和null")]),t._v(" "),_("li",[t._v("undefined代表的含义是"),_("strong",[t._v("未定义")]),t._v("，null代表的含义是"),_("strong",[t._v("空对象")]),t._v("。一般变量声明了但还没有定义的时候会返回undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化")]),t._v(" "),_("li",[t._v("undefined在JavaScript中不是一个保留字，这意味着可以使用undefined来作为一个变量名，但是这样的做法是非常危险的，它会影响对undefined值的判断。我们可以通过一些方法获得安全的undefined值，比如说void 0")]),t._v(" "),_("li",[t._v("typeof null 的返回值为object，且undefined == null 返回true")])]),t._v(" "),_("h2",{attrs:{id:"_6-this的指向问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-this的指向问题"}},[t._v("#")]),t._v(" 6.this的指向问题")]),t._v(" "),_("blockquote",[_("p",[t._v("this 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象")])]),t._v(" "),_("p",[_("strong",[t._v("this 永远指向最后调用它的那个对象")])]),t._v(" "),_("ul",[_("li",[t._v("函数调用模式：当一个函数不是一个对象的属性，直接作为函数来调用时，this指向全局对象")]),t._v(" "),_("li",[t._v("方法调用模式：当一个函数作为一个对象的方法来调用时，this指向这个对象")]),t._v(" "),_("li",[t._v("构造器调用模式：如果一个函数使用new调用时，函数在执行前会创建一个新的对象，this指向这个新的对象")])]),t._v(" "),_("blockquote",[_("p",[t._v("如何改变this的指向？")])]),t._v(" "),_("ul",[_("li",[t._v("使用ES6箭头函数，箭头函数不能绑定this，箭头函数的this使用指向函数定义时的this")]),t._v(" "),_("li",[t._v("在函数内部定义一个变量_this保存this")]),t._v(" "),_("li",[t._v("使用apply、call、bind")]),t._v(" "),_("li",[t._v("new实例化一个对象")])]),t._v(" "),_("blockquote",[_("p",[t._v("this绑定的优先级：new绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级")])]),t._v(" "),_("h2",{attrs:{id:"_7-apply、bind和call"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-apply、bind和call"}},[t._v("#")]),t._v(" 7.apply、bind和call")]),t._v(" "),_("blockquote",[_("p",[t._v("apply、bind和call都可以改变this的指向")])]),t._v(" "),_("p",[_("strong",[t._v("apply(thisArg[,argArray])")])]),t._v(" "),_("blockquote",[_("p",[t._v("apply() 方法调用一个具有给定this值的函数，以及以一个数组（或一个类数组对象）的形式提供的参数")])]),t._v(" "),_("p",[t._v("thisArr：在函数运行时使用的 this 值。请注意，this 可能不是该方法看到的实际值：如果这个函数处于非严格模式下")]),t._v(" "),_("h2",{attrs:{id:"_8-伪数组-类数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-伪数组-类数组"}},[t._v("#")]),t._v(" 8.伪数组（类数组）")]),t._v(" "),_("blockquote",[_("p",[t._v("一个拥有length属性和若干索引属性的对象可以被称为类数组对象，类数组对象和数组类似，但不能调用数组方法\n常用的类数组对象：arguments和DOM方法的返回结果，还有"),_("strong",[t._v("一个函数")]),t._v("也可以被看作是类数组对象，因为它含有length属性值，代表可接收参数个数")])])])}),[],!1,null,null,null);_.default=e.exports}}]);